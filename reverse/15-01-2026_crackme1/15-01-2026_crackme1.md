# [RE] - crackme1 by adamziaja
Crackmes.one link: [here](https://crackmes.one/crackme/5ab77f5533c5d40ad448c1df)

> This crackme has been imported from crackmes.de. The original author is adamziaja. The password of the archive is "crackmes.de"

> Last update: 15-01-2026
---

# Phân tích ban đầu
File gốc: `crackme1.tar.gz`     
Giải nén thu được `crackme1`

---
## Kiểm tra file:
```
└─$ file crackme1
crackme1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=15edebdd57e083d5f5a69544987f9983560273e0, with debug_info, not stripped
```

Là chương trình thực thi Linux 64-bit (ELF), chạy trên x86-64, có debug symbol, chưa bị strip

---
## Chạy thử chương trình
```
└─$ ./crackme1
username:
Arthur
username must be between 8 and 12!
username:
Arthur001
serial number:
992212
s/n WRONG!
```   

---
## Dùng Ghidra disassembly code

Thử nhiều lần nhận thấy `serial number` luôn sai. Đoán rằng mấu chốt giải quyết bài toán nằm ở cách gen `serial number`.

Dùng Ghidra disassembly code, search keyword `s/n WRONG!`

```
                             main.cpp:42 (30)
        0040137a 8b 85 d0        MOV        EAX,dword ptr [RBP + serial]
                 fc ff ff
        00401380 f2 0f 2a c0     CVTSI2SD   XMM0,EAX
        00401384 f2 0f 10        MOVSD      XMM1,qword ptr [RBP + sn]
                 8d 08 fd 
                 ff ff
        0040138c 66 0f 2e c1     UCOMISD    XMM0,XMM1
        00401390 7a 24           JP         LAB_004013b6
        00401392 66 0f 2e c1     UCOMISD    XMM0,XMM1
        00401396 75 1e           JNZ        LAB_004013b6
                             main.cpp:43 (30)
        00401398 be ea 15        MOV        ESI,s_s/n_OK!_004015ea                           = "s/n OK!"
                 40 00
        0040139d bf 40 22        MOV        EDI,std::cout
                 60 00
        004013a2 e8 09 fb        CALL       <EXTERNAL>::std::operator<<                      ostream * operator<<(ostream * p
                 ff ff
        004013a7 be 50 0f        MOV        ESI,std::endl<>
                 40 00
        004013ac 48 89 c7        MOV        RDI,RAX
        004013af e8 7c fb        CALL       <EXTERNAL>::std::ostream::operator<<             undefined operator<<(void * this
                 ff ff
        004013b4 eb 1c           JMP        LAB_004013d2
                             LAB_004013b6                                    XREF[2]:     00401390(j), 00401396(j)  
                             main.cpp:45 (28)
        004013b6 be f2 15        MOV        ESI,s_s/n_WRONG!_004015f2                        = "s/n WRONG!"
                 40 00
```

Nhìn vào đoạn mã trên, ta thấy:
- Từ `0040138c` đến `00401396` đang so sánh 2 thanh ghi SSE XMM0 và XMM1
- Nếu không bằng nhau -> JNZ nhảy tới `LAB_004013b6` -> in "WRONG!"
- Nếu bằng nhau -> tiếp tục in "OK!"

Mục tiêu của chúng ta phải làm cho `XMMO == XMM1` tại địa chỉ `00401396` thì sẽ in ra "OKE!"

---
## Debug bằng GDB
Mục đích dùng GDB debug để ta có thể `nhìn tận mắt` giá trị của `XMM0`, `XMM1` và các thanh ghi khác khi chương trình đang chạy

---
Đặt breakpoint tại lệnh so sánh có địa chỉ `00401396`

Nạp file crackme1:
```
pwndbg> file ./crackme1
Reading symbols from ./crackme1...
```

---

Đặt breakpoint tại `00401396`:
```
pwndbg> break *0x00401396
Breakpoint 1 at 0x401396: file main.cpp, line 42.
```

`*0x` vì địa chỉ bộ nhớ luôn luôn được biểu diễn ở dạng HEX và với `*` là con trỏ tới bộ nhớ

---
Chạy lại chương trình:

```
pwndbg> run
Starting program: /mnt/hgfs/WorkSpace/Save-Challenges/5ab77f5533c5d40ad448c1df/crackme1 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/usr/lib/x86_64-linux-gnu/libthread_db.so.1".
username:
01234567
serial number:
9992
```

---
Xem giá trị của `XMM0` & `XMM1` sau khi chạy xong chương trình:

```
pwndbg> p $xmm0
$3 = {
  v8_bfloat16 = {0, 5.629e+14, 8.724e-20, 16.88, 0, 0, 0, 0},
  v8_half = {0, 128, 0.0076218, 2.7637, 0, 0, 0, 0},
  v4_float = {5.62949953e+14, 16.8905296, 0, 0},
  v2_double = {48495051, 0},
  v16_int8 = {0, 0, 0, 88, -50, 31, -121, 65, 0, 0, 0, 0, 0, 0, 0, 0},
  v8_int16 = {0, 22528, 8142, 16775, 0, 0, 0, 0},
  v4_int32 = {1476395008, 1099374542, 0, 0},
  v2_int64 = {4721777705421373440, 0},
  uint128 = 4721777705421373440
}
pwndbg> p $xmm1
$4 = {
  v8_bfloat16 = {0, 0, -1.505e-36, 6.094, 0, 0, 0, 0},
  v8_half = {0, 0, -6.1035e-05, 2.3809, 0, 0, 0, 0},
  v4_float = {0, 6.10986328, 0, 0},
  v2_double = {9992, 0},
  v16_int8 = {0, 0, 0, 0, 0, -124, -61, 64, 0, 0, 0, 0, 0, 0, 0, 0},
  v8_int16 = {0, 0, -31744, 16579, 0, 0, 0, 0},
  v4_int32 = {0, 1086555136, 0, 0},
  v2_int64 = {4666718774420832256, 0},
  uint128 = 4666718774420832256
}
```

Tại `XMM0` giá trị của v2_double là giá trị của username sau khi chuyển sang ASCII code: `48495051`
Mỗi cặp số tương ứng với mỗi ký tự của username:
```
48 = '0'
49 = '1'
50 = '2'
51 = '3'
```

---
## Giả thuyết thuật toán 1 - Kiểm tra
- Lấy ASCII từng ký tự
- Nỗi lại thành chuỗi
- Cắt chuỗi ASCII lấy 8 chữ số đầu tiên = `serial`

---
Code keygen
```
def keygen_version1(username: str) -> str:
    key = ""
    for u in username:
        key += str(ord(u))
    return key[:8]
```
---
### Kiểm tra với username: `abcdefgh`

Với keygen_version1()
```
serial: 97989910
```

Kiểm tra thanh ghi XMM0, EAX
```
XMM0 = 97669968
EAX = 97669968
```

So sánh:
```
'a' = 97 -> Đúng
'b' = 98 -> thành 66 (98 - 32), giảm 32 bit
'c' = 99 -> Đúng
'd' = 100 -> Đúng, trong chuỗi thấy 10 do cắt chuỗi chỉ lấy 8 ký tự đầu
```

Nhân xét:
- 97, 99 (a, c) giữ nguyên -> đúng như mã ASCII mong đợi
- 98, 100 lại bị giảm 32 bit thành 66, 68

Kết luận:
- Vậy thuật toán keygen phía trên là đúng. 
- Ký tự là chẵn sẽ giảm 32bit để chuyển thành in hoa

---
Kiểm tra với `ABCDEFGH`:

Thanh ghi chương trình XMM0, EAX giống nhau -> Ký tự lẻ chuyển sang chữ thường

---
Kiểm tra lại lần nữa với nhiều trường hợp username khác nhau:
```
abcdefgh = 97669968
abcdefghi = 66996810
abcdefghij = 99681017
abcdefghijk = 68101701
abcdefghijkl = 10170103
```

Kết luận: 
- Thuật toán đúng
- Chuyển đổi giữa thường và in hoa dựa vào index chứ ko phải chẵn lẻ của ASCII (+-32bit)

---
## Giả thuyết thuật toán 2 - Kiểm tra
Update từ thuật toán 1
- Ký tự chẵn in hoa
- Ký tự lẽ in thường
- Nối ASCII lại
- Lấy 8 chữ số đầu

---
Code version 2
```
def keygen_version2(username: str) -> str:
    key = ""
    for i, u in enumerate(username):
        if i % 2:
            key += str(ord(u.upper()))
        else:
            key += str(ord(u.lower()))
    return key[:8]
```

---
Kiểm tra username dài hơn 8 ký tự
```
abcdefgh = 97669968
abcdefghi = 66996810
abcdefghij = 99681017
abcdefghijk = 68101701
abcdefghijkl = 10170103
```

Nhận xét:
- Serial luôn là 8 chữ số
- Nhưng giá trị không phải là 8 chữ số đầu
Suy ra có quy luật dịch chuyển khi cắt chuỗi

---
Thấy rằng, quy luật cắt chuỗi như sau:

| Độ dài username | Byte được lấy |
| --------------- | ------------- |
| 8               | 0–7           |
| 9               | 2–9           |
| 10              | 4–11          |
| 11              | 6–13          |
| 12              | 8–15          |


Suy ra, offset = `2 x (len(username) - 8)`
`
---
Thuật toán hoàn chỉnh:
```
def generate_key(username):
    if not 8 <= len(username) <= 12:
        print("username must be between 8 and 12 characters.")
        quit()
    key = ''
    for i, u in enumerate(username):
        if i % 2:
            key += str(ord(u.upper()))
        else:
            key += str(ord(u.lower()))
    return int(key[2*(len(username)-8):][0:8])

```



























